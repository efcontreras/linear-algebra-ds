{
  "hash": "0a5bd3cb64ae4dc632c24a31a7a507a3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Singular Value Decomposition (SVD)\"\n---\n\n## Why SVD matters\n\nSVD is the most useful factorization in applied linear algebra. It powers:\n- low-rank approximation (compression),\n- PCA (via $X^\\top X$ or directly via SVD),\n- recommender systems,\n- numerical stability and conditioning.\n\n## Statement\n\n::: {.mathbox .theorem}\n<div class=\"mathbox-title\">Theorem (SVD)</div>\n\nFor any matrix $A\\in\\mathbb{R}^{m\\times n}$, there exist orthogonal matrices\n$U\\in\\mathbb{R}^{m\\times m}$, $V\\in\\mathbb{R}^{n\\times n}$ and a diagonal matrix\n$\\Sigma\\in\\mathbb{R}^{m\\times n}$ with nonnegative diagonal entries\n$\\sigma_1\\ge \\sigma_2\\ge\\cdots\\ge 0$ such that\n$$\nA = U\\,\\Sigma\\,V^\\top.\n$$\nThe numbers $\\sigma_i$ are the **singular values** of $A$.\n:::\n\n## Geometric interpretation\n\n- $V^\\top$ rotates (or reflects) the input space.\n- $\\Sigma$ stretches along coordinate axes by factors $\\sigma_i$.\n- $U$ rotates (or reflects) the output space.\n\n## Best rank-$k$ approximation (Eckart–Young)\n\nLet\n$$\nA_k := \\sum_{i=1}^k \\sigma_i\\,u_i v_i^\\top.\n$$\n\n::: {.mathbox .theorem}\n<div class=\"mathbox-title\">Theorem (Eckart–Young–Mirsky, informal)</div>\n\n$A_k$ is the best rank-$k$ approximation of $A$ in the Frobenius norm:\n$$\n\\|A - A_k\\|_F = \\min_{\\mathrm{rank}(B)\\le k}\\|A-B\\|_F.\n$$\n:::\n\n## Data Science demo: low-rank approximation as compression\n\n::: {#65958165 .cell execution_count=1}\n```` { .cell-code}\n```{{python}}\nimport numpy as np\n\nrng = np.random.default_rng(0)\n\n# Build a low-rank-ish matrix: signal + noise\nm, n, r = 200, 120, 5\nU0 = rng.normal(size=(m, r))\nV0 = rng.normal(size=(n, r))\nA_signal = U0 @ V0.T\nA = A_signal + 0.2 * rng.normal(size=(m, n))\n\n# SVD\nU, s, Vt = np.linalg.svd(A, full_matrices=False)\n\ndef low_rank(k: int) -> np.ndarray:\n  return (U[:, :k] * s[:k]) @ Vt[:k, :]\n\n# Compare reconstruction error\nerrs = []\nfor k in [1, 2, 5, 10, 20]:\n  Ak = low_rank(k)\n  err = np.linalg.norm(A - Ak, ord=\"fro\") / np.linalg.norm(A, ord=\"fro\")\n  errs.append((k, err))\n\nerrs\n```\n\n````\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n[(1, np.float64(0.8386868479642773)),\n (2, np.float64(0.6921391932867184)),\n (5, np.float64(0.08740357102216885)),\n (10, np.float64(0.08200082537293461)),\n (20, np.float64(0.07218572433581102))]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "05-svd_files"
    ],
    "filters": [],
    "includes": {}
  }
}